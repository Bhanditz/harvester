c
name.parse_quality
name.parsed?
name.verbatim
name.canonical
name.normalized
name
l
url = "http://localhost:3000/resources/#{resource.repository_id}/nodes.json&page=#{page}"
c
json = "[#{json}]"
puts json[-100..-1]
puts json[0..100]
c
q
@format.diff
c
json = json[95..-1] ; 1
json[94..100]
json[90..100]
q
json[0..100]
 te":false,"virus":false,"bacteria":false,"details":[{"genus":{"value":"Hippochrenes"},"specific_epithet":{"value":"bailei","authorship":{"value":"(Deshayes 1865)","basionym_authorship":{"authors":["Deshayes"],"year":{"value":"1865"}}}}}],"positions":[["genus",0,12],["specific_epithet",13,19],["author_word",21,29],["year",31,35]]},{"name_string_id":"cb6b788e-f5b9-5aef-a0f8-f1eb516722ee","parsed":true,"quality":1,"parser_version":"0.4.1","verbatim":"Tibia miniaensis Abbass, 1967","normalized":"Tibia miniaensis Abbass 1967","canonical_name":{"value":"Tibia miniaensis"},"hybrid":false,"surrogate":false,"virus":false,"bacteria":false,"details":[{"genus":{"value":"Tibia"},"specific_epithet":{"value":"miniaensis","authorship":{"value":"Abbass 1967","basionym_authorship":{"authors":["Abbass"],"year":{"value":"1967"}}}}}],"positions":[["genus",0,5],["specific_epithet",6,16],["author_word",17,23],["year",25,29]]},{"name_string_id":"1382ee14-949c-5b1a-adcb-830e03464d97","parsed":true,"quality":1,"parser_version":"0.4. 
q
models.count
models.first
l-
l
puts e.message[0..100]
puts e.message
q
puts e.backtrace
puts @models
puts e.message
puts model
quit
c
scores
c
quit
q
normal = NormalizedName.where(string: name.normalized, canonical: name.canonical).first_or_create
norm = NormalizedName.first_or_create(string: name.normalized, canonical: name.canonical)
c
n
name.canonical
name.normalized
normal
name
c
name
normal
q
puts hash
puts k
puts v
puts k
hash
puts e.backtrace[0..3]
@names
puts e.message
q
@names_file
@names.key?('Sinella gracilis Zhang, 2013')
@names.key?('Sinella gei Pan, Zhang & Shi, 2012')
result['verbatim']
@names.key?(result['verbatim'])
result['verbatim']
puts e.backtrace[0..3]
puts e.message
attributes['infraspecific_epithet'] = attributes.delete('infraspecific_epithets')
puts e.message
puts e.messages
q
! result['parsed']
result['parsed'].false?
result['parsed']
quality
norm = result['verbatim']
result
norm
c
year = hash['authorship']['basionym_authorship']['year']['value'] if hash['authorship']['basionym_authorship'].key?('year')
            hash['authorship']['basionym_authorship'].key?('year')
          year = hash['authorship']['basionym_authorship']['year']['value'] if
hash['authorship']
puts e.backtrace[0..3]
puts e.message
c
puts e.message
c
puts e.message
c
puts e.message
c
puts e.message
c
puts e.backtrace[0..10]
puts e.message
puts e
@harvest
c
harvester.harvest
@harvest
@harvest.id
q
quit
@models
@file
q
@models
q
c
q
pp @file
pp @harvester
c
json = "[" + File.read(outfile).gsub("\n", ",").chop + "]"
_, stdout, stderr = Open3.popen3("gnparse file --input #{filename} --output #{outfile}")
        "--output #{outfile}")
_, stdout, stderr = Open3.popen3("gnparse file --input #{filename} "\
File.open(filename, "w") { |file| file.write(@verbatims) }
pp e.message
q
c
row
row.values.compact.size < (row.values.size / 5)
row.values.size / 5
row.values.compact.size
puts e.message
occurrence
n
s
n
s
n
@models[:occurrence]
@models
n
row
q
n
s
n
s
@formats[fid][:headers]
@formats[fid][:parser]
fmt
n
fid
n
l-
lk-
l-
n
s
l
n
c
n
any_diff
n
fields
n
q
quit
c
q
c
q
@harvest.formats.find { |fmt| fmt.data_measurements? }
@harvest.formats
field
firle
@field
@harvest.warn
@format
puts e.message
n
q
puts e
n
q
predicate_term
n
predicate
n
q
predicate
predicate_term
@models[:trait][:predicate_term_id]
@models[:trait]
c
q
@terms
c
puts e.backtrace[0..1]
puts e.message
c
row
exit
fmt.file
fmt
Format.where(resource_id: resource.id, represents: Format.represents[:data_measurements]).count
fmt2 = Format.where(resource_id: resource.id, represents: Format.represents[:data_measurements]).last
parsera
fmt.diff
fmt
diff
line_number
row
q
row
fmt.represents
fmt
q
fmt.represents
fmt
n
diff
n
row
n
row
headers
line_number
c
fmt.represents
c
fmt.represents
c
fmt.represents
fmt.file_type
fmt
c
@models[:trait]
predicate
n
@models[:trait][:of_taxon]
n
@models[:trait][:harvest_id]
n
@models[:trait][:resource_id]
n
@models[:trait][:trait_resource_pk]
exit
node_pk
backtrace
c
 c
q
c
parser.rows_as_hashes { |h| pp h }
parser.rows_as_hashes
parser.headers
parser = CsvParser.new(fmt.get_from, field_sep: fmt.field_sep, line_sep: fmt.line_sep, header_lines: fmt.header_lines, data_begins_on_line: fmt.data_begins_on_line)
