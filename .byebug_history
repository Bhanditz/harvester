c
scores
c
quit
q
normal = NormalizedName.where(string: name.normalized, canonical: name.canonical).first_or_create
norm = NormalizedName.first_or_create(string: name.normalized, canonical: name.canonical)
c
n
name.canonical
name.normalized
normal
name
c
name
normal
q
puts hash
puts k
puts v
puts k
hash
puts e.backtrace[0..3]
@names
puts e.message
q
@names_file
@names.key?('Sinella gracilis Zhang, 2013')
@names.key?('Sinella gei Pan, Zhang & Shi, 2012')
result['verbatim']
@names.key?(result['verbatim'])
result['verbatim']
puts e.backtrace[0..3]
puts e.message
attributes['infraspecific_epithet'] = attributes.delete('infraspecific_epithets')
puts e.message
puts e.messages
q
! result['parsed']
result['parsed'].false?
result['parsed']
quality
norm = result['verbatim']
result
norm
c
year = hash['authorship']['basionym_authorship']['year']['value'] if hash['authorship']['basionym_authorship'].key?('year')
            hash['authorship']['basionym_authorship'].key?('year')
          year = hash['authorship']['basionym_authorship']['year']['value'] if
hash['authorship']
puts e.backtrace[0..3]
puts e.message
c
puts e.message
c
puts e.message
c
puts e.message
c
puts e.message
c
puts e.backtrace[0..10]
puts e.message
puts e
@harvest
c
harvester.harvest
@harvest
@harvest.id
q
quit
@models
@file
q
@models
q
c
q
pp @file
pp @harvester
c
json = "[" + File.read(outfile).gsub("\n", ",").chop + "]"
_, stdout, stderr = Open3.popen3("gnparse file --input #{filename} --output #{outfile}")
        "--output #{outfile}")
_, stdout, stderr = Open3.popen3("gnparse file --input #{filename} "\
File.open(filename, "w") { |file| file.write(@verbatims) }
pp e.message
q
c
row
row.values.compact.size < (row.values.size / 5)
row.values.size / 5
row.values.compact.size
puts e.message
occurrence
n
s
n
s
n
@models[:occurrence]
@models
n
row
q
n
s
n
s
@formats[fid][:headers]
@formats[fid][:parser]
fmt
n
fid
n
l-
lk-
l-
n
s
l
n
c
n
any_diff
n
fields
n
q
quit
c
q
c
q
@harvest.formats.find { |fmt| fmt.data_measurements? }
@harvest.formats
field
firle
@field
@harvest.warn
@format
puts e.message
n
q
puts e
n
q
predicate_term
n
predicate
n
q
predicate
predicate_term
@models[:trait][:predicate_term_id]
@models[:trait]
c
q
@terms
c
puts e.backtrace[0..1]
puts e.message
c
row
exit
fmt.file
fmt
Format.where(resource_id: resource.id, represents: Format.represents[:data_measurements]).count
fmt2 = Format.where(resource_id: resource.id, represents: Format.represents[:data_measurements]).last
parsera
fmt.diff
fmt
diff
line_number
row
q
row
fmt.represents
fmt
q
fmt.represents
fmt
n
diff
n
row
n
row
headers
line_number
c
fmt.represents
c
fmt.represents
c
fmt.represents
fmt.file_type
fmt
c
@models[:trait]
predicate
n
@models[:trait][:of_taxon]
n
@models[:trait][:harvest_id]
n
@models[:trait][:resource_id]
n
@models[:trait][:trait_resource_pk]
exit
node_pk
backtrace
c
 c
q
c
parser.rows_as_hashes { |h| pp h }
parser.rows_as_hashes
parser.headers
parser = CsvParser.new(fmt.get_from, field_sep: fmt.field_sep, line_sep: fmt.line_sep, header_lines: fmt.header_lines, data_begins_on_line: fmt.data_begins_on_line)
                          data_begins_on_line: fmt.data_begins_on_line)
                          field_sep: fmt.field_sep, line_sep: fmt.line_sep, header_lines: fmt.header_lines,
parser = CsvParser.new(fmt.get_from,
fmt = Format.find(9)
fmt
@format
fmt = Format.find
@models[:trait]
c
@nodes
node_pk
c
@models[:trait]
pk
      ocrc = @occurrences[pk] |
@occurrences
@nodes
@occurrences
c
@models[:trait][:occurrence_resource_pk] = "Javania pseudoalabastra Zibrowius, 1974"
@models[:trait][:occurrence_resource_pk]
@models[:trait]
keys
diff
c
$FOO = 0
$FOO
c
occurrence
@models[:trait]
occurrence
n
@models[:trait]
parent
n
parent
