quit
puts e
q
puts e.backtrace
puts e
quit
puts node_pk
quit
puts row
puts node_pk
quit
puts e.backtrace
puts e
q
fmt.fields.sort_by(&:position).map(&:expected_header)
fmt.fields.sort_by(&:position)
fmt.fields.sort_by(:position)
fmt.fields
fmt
format
row
q
quit
fmt
        nil
        @previous_harvest.formats.find { |f| f.represents == fmt.represents } :
other_fmt = @previous_harvest ?
other_fmt.represents
other_fmt
fmt
        nil
        @previous_harvest.formats.find { |f| f.file_type == fmt.file_type } :
other_fmt = @previous_harvest ?
@previous_harvest = Harvest.find 8
fmt = Format.find 56
irb
        nil
        @previous_harvest.formats.find { |f| f.file_type == fmt.file_type } :
other_fmt = @previous_harvest ?
@previous_harvest = Harvest.find 8
fmt = Format.find 56
quit
field.format
fmt
q
c
val
q
puts e
q
puts e.backtrace
puts e.message
q
qy
puts e.backtrace
puts e.message
quit
puts e.message
c
quit
puts @models[:medium]
q
c
@models[:medium]
node
@models[:medium]
c
@models[:medium]
q
pp @models[:medium]
puts e.message
  harvester.complete_harvest_instance
quit
  harvester.complete_harvest_instance
quit
end
  end
    end
      @models[:medium][:source_url] = val
    d    d    d    d    d    d    dva    d    d    d    d    d ||= {}
    e  
      @models[:medium][:description] = val
      @models[:medium] ||= {}
    def to_media_description(field, val)
    end
      @models[:medium][:name] = val
      @models[:medium] ||= {}
    def to_media_name(field, val)
    end
      @models[:medium][:subclass] = Medium.subclasses[type]
      end
        :image
        field.format.warn("Could not find a media subtype of \"#{val.downcase}\"")
      else
        @media_type_mappings[val.downcase]
      type = if @media_type_mappings.has_key?(val.downcase)
      }
        "map_js" => :map_js
        "map_image" => :map_image,
        "sound" => :sound,
        "video" => :video,
        "image" => :image,
      @media_type_mappings ||= {
      # used.
      # TODO: lots more to these mappings, especially the URIs that commonly get
      @models[:medium] ||= {}
    def to_media_type(field, val)
    end
      @models[:medium][:node_resource_pk] = val # TODO: we will "find" it later.
      @models[:medium] ||= {}
    def to_nodes_fk(field, val)
    end
      @models[:medium][:resource_pk] = val
      @models[:medium] ||= {}
    def to_media_pk(field, val)
  module Media
module Store
  module Media
module Store
puts e.backtrace
puts e.message
q
puts @models[:ancestors]
puts e.backtrace
puts e.message
q
puts e.backtrace
puts e
q
@models[:parent_node]
puts parent_id
pp @models[:ancestors]
ancestor[:node]
ancestor[:node].is_a?(Hash)
pp ancestor
q
puts e.backtrace
puts e.message
c
q
puts model
c
puts model
c
puts model
c
puts model
c
puts model
c
puts model
c
puts ScientificName.find(22).verbatim
puts model
q
puts e.backtrace
 q
puts e.backtrace
pp @models ; 1
puts @models ; 1
puts e.message
q
puts e.message
c
q
@models[:node]
pp node
n
s
c
s
pp node_hash ; 1
s
puts ScientificName.find(4).verbatim
puts ScientificName.find 4
puts ancestor[:node]
c
q
foo.scientific_name
foo.name_verbatim
puts ancestor[:node]
foo
foo = build_any_node(ancestor[:node], :new, keys)
pp ancestor[:node] ; 1
c
q
ancestor[:sci_name].id
pp ancestor ; 1
pp ancestor
pp ancestor[:node]
c
pp @models[:ancestors]
q
pp ancestor[:node]
c
pp ancestor[:node].id
pp ancestor[:node].ids
puts parent_id
pp ancestor[:node]
puts ancestor[:node]
q
puts @models[:ancestors]
puts ancestor
q
puts e.backtrace
puts e.backtrace?
puts e.message
q
pp ancestor
pp ancesotr
puts ancestor[:node]
puts foo
q
puts foo.nil?
puts foo.class
puts foo
ancestor[:node]
puts e.message
q
puts e.backtrace
puts e.message
q
puts e.backtrace
q
puts foo
q
c
puts foo
c
puts foo
c
puts foo
c
puts foo
c
puts foo
c
puts foo
c
puts foo
c
puts foo
c
puts foo
c
puts foo
quit
puts e.backtrace
puts e.message
q
puts parent_id
@models[:parent_node]
Node.where(resource_pk: "tax12").exists?
Node.where(resource_pk: "tax12")
puts @models[:parent_node]
q
